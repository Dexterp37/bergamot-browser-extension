/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

"use strict";

/**
 * Represents a request (for 1 chunk) sent off to Bergamot's service.
 *
 * @params translationData  The data to be used for this translation,
 *                          generated by the generateNextTranslationRequest...
 *                          function.
 * @param sourceLanguage    The source language of the document.
 * @param targetLanguage    The target language for the translation.
 *
 */
function BergamotRequest(translationData, sourceLanguage, targetLanguage) {
  this.translationData = translationData;
  this.sourceLanguage = sourceLanguage;
  this.targetLanguage = targetLanguage;
  this.characterCount = 0;
}

BergamotRequest.prototype = {
  /**
   * Initiates the request
   */
  fireRequest(url) {
    // Prepare the headers
    let headers = [
      ["Content-Type", "application/json"],
    ]

    // Prepare the post data
    let postData = {
      "text"  : [],
      "options" : {"returnSentenceScore" : true}
    };

    // Prepare the content of the post
    for (let [, text] of this.translationData) {
      // The next line is a hack to delay dealing with the problem of
      //               <b>Do not</b> touch.
      // being translated to something like
      //           <b>Ne</b> touche <b>pas</b>.
      // The server can only deal with pure text. The client has no
      // knowledge of semantics. So it can not remove the tags and
      // replace them as it doesn't know how to insert them in to
      // the translated result. So as a hack we just remove the
      // tags and hope the formatting is not too bad.
      text = text.replace(/<[^>]*>?/gm, ' ');
      postData["text"].push(text);
      this.characterCount += text.length;
    }

    // Convert the post to a string
    postData = JSON.stringify(postData);

    // Set up request options.
    return new Promise((resolve, reject) => {
      let options = {
        onLoad: (responseText, xhr) => {
          resolve(this);
        },
        onError(e, responseText, xhr) {
          reject(xhr);
        },
        postData,
        headers,
      };

      // Fire the request.
      this.networkRequest = httpRequest(url, options);
    });
  },
};
